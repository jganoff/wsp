use std::fmt;
use std::fs;
use std::path::{Path, PathBuf};

use anyhow::{Context, Result};

use crate::giturl;
use crate::workspace::Metadata;

use super::LanguageIntegration;

const DEFAULT_GO_VERSION: GoVersion = GoVersion {
    major: 1,
    minor: 21,
};

pub struct GoIntegration;

impl LanguageIntegration for GoIntegration {
    fn name(&self) -> &str {
        "go"
    }

    fn detect(&self, ws_dir: &Path, metadata: &Metadata) -> bool {
        repo_dirs(ws_dir, metadata)
            .iter()
            .any(|(_, path)| path.join("go.mod").exists())
    }

    fn apply(&self, ws_dir: &Path, metadata: &Metadata) -> Result<()> {
        let dirs = repo_dirs(ws_dir, metadata);
        let mut entries: Vec<(String, GoVersion)> = Vec::new();

        for (name, path) in &dirs {
            let go_mod = path.join("go.mod");
            if !go_mod.exists() {
                continue;
            }
            let content = fs::read_to_string(&go_mod)
                .with_context(|| format!("reading {}", go_mod.display()))?;
            let version = parse_go_version(&content).unwrap_or(DEFAULT_GO_VERSION);
            entries.push((name.clone(), version));
        }

        if entries.is_empty() {
            return Ok(());
        }

        let max_version = entries
            .iter()
            .map(|(_, v)| v)
            .max()
            .cloned()
            .unwrap_or(DEFAULT_GO_VERSION);

        let mut names: Vec<&str> = entries.iter().map(|(n, _)| n.as_str()).collect();
        names.sort();

        let mut out = String::new();
        out.push_str("// Code generated by ws. DO NOT EDIT.\n");
        out.push_str(&format!("go {}\n", max_version));
        out.push('\n');
        out.push_str("use (\n");
        for name in &names {
            out.push_str(&format!("\t./{}\n", name));
        }
        out.push_str(")\n");

        let tmp_path = ws_dir.join(".go.work.tmp");
        let final_path = ws_dir.join("go.work");
        fs::write(&tmp_path, out).with_context(|| format!("writing {}", tmp_path.display()))?;
        fs::rename(&tmp_path, &final_path).with_context(|| {
            format!(
                "renaming {} to {}",
                tmp_path.display(),
                final_path.display()
            )
        })?;
        Ok(())
    }
}

/// Returns (repo_name, repo_path) for all repos in the workspace.
fn repo_dirs(ws_dir: &Path, metadata: &Metadata) -> Vec<(String, PathBuf)> {
    let mut result = Vec::new();
    for identity in metadata.repos.keys() {
        if let Ok(parsed) = giturl::Parsed::from_identity(identity) {
            if parsed.repo.contains("..") || parsed.repo.starts_with('/') {
                continue;
            }
            let path = ws_dir.join(&parsed.repo);
            result.push((parsed.repo, path));
        }
    }
    result
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub struct GoVersion {
    pub major: u32,
    pub minor: u32,
}

impl fmt::Display for GoVersion {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}.{}", self.major, self.minor)
    }
}

/// Parses the `go X.Y` directive from go.mod content.
pub fn parse_go_version(content: &str) -> Option<GoVersion> {
    for line in content.lines() {
        let line = line.trim();
        if let Some(rest) = line.strip_prefix("go ") {
            let rest = rest.trim();
            // Take only major.minor, ignore patch (e.g. "1.23.2" -> "1.23")
            let parts: Vec<&str> = rest.split('.').collect();
            if parts.len() >= 2
                && let (Ok(major), Ok(minor)) = (parts[0].parse(), parts[1].parse())
            {
                return Some(GoVersion { major, minor });
            }
        }
    }
    None
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::collections::BTreeMap;

    use chrono::Utc;

    use crate::workspace::{Metadata, WorkspaceRepoRef};

    #[test]
    fn test_parse_go_version() {
        let cases = vec![
            (
                "standard",
                "module example.com/foo\n\ngo 1.21\n",
                Some(GoVersion {
                    major: 1,
                    minor: 21,
                }),
            ),
            (
                "with patch",
                "module example.com/foo\n\ngo 1.23.2\n",
                Some(GoVersion {
                    major: 1,
                    minor: 23,
                }),
            ),
            ("missing", "module example.com/foo\n", None),
            ("empty", "", None),
            (
                "with toolchain",
                "module example.com/foo\n\ngo 1.22\n\ntoolchain go1.22.5\n",
                Some(GoVersion {
                    major: 1,
                    minor: 22,
                }),
            ),
            (
                "go 2.0",
                "module example.com/foo\n\ngo 2.0\n",
                Some(GoVersion { major: 2, minor: 0 }),
            ),
        ];
        for (name, input, want) in cases {
            let got = parse_go_version(input);
            assert_eq!(got, want, "{}", name);
        }
    }

    #[test]
    fn test_go_version_ordering() {
        let cases = vec![
            (
                "1.21 < 1.22",
                GoVersion {
                    major: 1,
                    minor: 21,
                },
                GoVersion {
                    major: 1,
                    minor: 22,
                },
                std::cmp::Ordering::Less,
            ),
            (
                "1.23 > 1.22",
                GoVersion {
                    major: 1,
                    minor: 23,
                },
                GoVersion {
                    major: 1,
                    minor: 22,
                },
                std::cmp::Ordering::Greater,
            ),
            (
                "1.21 == 1.21",
                GoVersion {
                    major: 1,
                    minor: 21,
                },
                GoVersion {
                    major: 1,
                    minor: 21,
                },
                std::cmp::Ordering::Equal,
            ),
            (
                "2.0 > 1.99",
                GoVersion { major: 2, minor: 0 },
                GoVersion {
                    major: 1,
                    minor: 99,
                },
                std::cmp::Ordering::Greater,
            ),
        ];
        for (name, a, b, want) in cases {
            assert_eq!(a.cmp(&b), want, "{}", name);
        }
    }

    #[test]
    fn test_go_version_display() {
        let v = GoVersion {
            major: 1,
            minor: 23,
        };
        assert_eq!(v.to_string(), "1.23");
    }

    fn make_metadata(repos: &[&str]) -> Metadata {
        let mut map = BTreeMap::new();
        for id in repos {
            map.insert(id.to_string(), None);
        }
        Metadata {
            name: "test".into(),
            branch: "test".into(),
            repos: map,
            created: Utc::now(),
        }
    }

    fn make_metadata_with_refs(repos: &[(&str, Option<&str>)]) -> Metadata {
        let mut map: BTreeMap<String, Option<WorkspaceRepoRef>> = BTreeMap::new();
        for (id, r) in repos {
            match r {
                None => {
                    map.insert(id.to_string(), None);
                }
                Some(ref_str) => {
                    map.insert(
                        id.to_string(),
                        Some(WorkspaceRepoRef {
                            r#ref: ref_str.to_string(),
                        }),
                    );
                }
            }
        }
        Metadata {
            name: "test".into(),
            branch: "test".into(),
            repos: map,
            created: Utc::now(),
        }
    }

    #[test]
    fn test_detect_with_go_mod() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        let repo_dir = ws_dir.join("api-gateway");
        fs::create_dir_all(&repo_dir).unwrap();
        fs::write(
            repo_dir.join("go.mod"),
            "module example.com/api-gateway\n\ngo 1.21\n",
        )
        .unwrap();

        let meta = make_metadata(&["github.com/acme/api-gateway"]);
        let integration = GoIntegration;

        assert!(integration.detect(ws_dir, &meta));
    }

    #[test]
    fn test_detect_without_go_mod() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        let repo_dir = ws_dir.join("frontend");
        fs::create_dir_all(&repo_dir).unwrap();
        fs::write(repo_dir.join("package.json"), "{}").unwrap();

        let meta = make_metadata(&["github.com/acme/frontend"]);
        let integration = GoIntegration;

        assert!(!integration.detect(ws_dir, &meta));
    }

    #[test]
    fn test_detect_mixed_repos() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        // One Go repo
        let go_dir = ws_dir.join("api-gateway");
        fs::create_dir_all(&go_dir).unwrap();
        fs::write(
            go_dir.join("go.mod"),
            "module example.com/api-gateway\n\ngo 1.21\n",
        )
        .unwrap();

        // One non-Go repo
        let js_dir = ws_dir.join("frontend");
        fs::create_dir_all(&js_dir).unwrap();
        fs::write(js_dir.join("package.json"), "{}").unwrap();

        let meta = make_metadata(&["github.com/acme/api-gateway", "github.com/acme/frontend"]);
        let integration = GoIntegration;

        assert!(integration.detect(ws_dir, &meta));
    }

    #[test]
    fn test_apply_single_repo() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        let repo_dir = ws_dir.join("api-gateway");
        fs::create_dir_all(&repo_dir).unwrap();
        fs::write(
            repo_dir.join("go.mod"),
            "module example.com/api-gateway\n\ngo 1.22\n",
        )
        .unwrap();

        let meta = make_metadata(&["github.com/acme/api-gateway"]);
        let integration = GoIntegration;
        integration.apply(ws_dir, &meta).unwrap();

        let content = fs::read_to_string(ws_dir.join("go.work")).unwrap();
        assert_eq!(
            content,
            "// Code generated by ws. DO NOT EDIT.\ngo 1.22\n\nuse (\n\t./api-gateway\n)\n"
        );
    }

    #[test]
    fn test_apply_multiple_repos_highest_version() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        let api_dir = ws_dir.join("api-gateway");
        fs::create_dir_all(&api_dir).unwrap();
        fs::write(
            api_dir.join("go.mod"),
            "module example.com/api-gateway\n\ngo 1.21\n",
        )
        .unwrap();

        let proto_dir = ws_dir.join("proto");
        fs::create_dir_all(&proto_dir).unwrap();
        fs::write(
            proto_dir.join("go.mod"),
            "module example.com/proto\n\ngo 1.23\n",
        )
        .unwrap();

        let user_dir = ws_dir.join("user-service");
        fs::create_dir_all(&user_dir).unwrap();
        fs::write(
            user_dir.join("go.mod"),
            "module example.com/user-service\n\ngo 1.22\n",
        )
        .unwrap();

        let meta = make_metadata(&[
            "github.com/acme/api-gateway",
            "github.com/acme/proto",
            "github.com/acme/user-service",
        ]);
        let integration = GoIntegration;
        integration.apply(ws_dir, &meta).unwrap();

        let content = fs::read_to_string(ws_dir.join("go.work")).unwrap();
        assert_eq!(
            content,
            "// Code generated by ws. DO NOT EDIT.\ngo 1.23\n\nuse (\n\t./api-gateway\n\t./proto\n\t./user-service\n)\n"
        );
    }

    #[test]
    fn test_apply_mixed_go_and_non_go() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        let go_dir = ws_dir.join("api-gateway");
        fs::create_dir_all(&go_dir).unwrap();
        fs::write(
            go_dir.join("go.mod"),
            "module example.com/api-gateway\n\ngo 1.22\n",
        )
        .unwrap();

        let js_dir = ws_dir.join("frontend");
        fs::create_dir_all(&js_dir).unwrap();
        fs::write(js_dir.join("package.json"), "{}").unwrap();

        let meta = make_metadata(&["github.com/acme/api-gateway", "github.com/acme/frontend"]);
        let integration = GoIntegration;
        integration.apply(ws_dir, &meta).unwrap();

        let content = fs::read_to_string(ws_dir.join("go.work")).unwrap();
        // Only the Go repo should appear
        assert!(content.contains("./api-gateway"));
        assert!(!content.contains("./frontend"));
    }

    #[test]
    fn test_apply_no_go_repos() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        let js_dir = ws_dir.join("frontend");
        fs::create_dir_all(&js_dir).unwrap();
        fs::write(js_dir.join("package.json"), "{}").unwrap();

        let meta = make_metadata(&["github.com/acme/frontend"]);
        let integration = GoIntegration;
        integration.apply(ws_dir, &meta).unwrap();

        // No go.work should be written
        assert!(!ws_dir.join("go.work").exists());
    }

    #[test]
    fn test_apply_sorted_output() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        // Create repos in non-alphabetical order
        for name in &["zebra", "alpha", "middle"] {
            let d = ws_dir.join(name);
            fs::create_dir_all(&d).unwrap();
            fs::write(d.join("go.mod"), "module example.com/x\n\ngo 1.21\n").unwrap();
        }

        let meta = make_metadata(&[
            "github.com/acme/zebra",
            "github.com/acme/alpha",
            "github.com/acme/middle",
        ]);
        let integration = GoIntegration;
        integration.apply(ws_dir, &meta).unwrap();

        let content = fs::read_to_string(ws_dir.join("go.work")).unwrap();
        let use_lines: Vec<&str> = content.lines().filter(|l| l.starts_with('\t')).collect();
        assert_eq!(use_lines, vec!["\t./alpha", "\t./middle", "\t./zebra"]);
    }

    #[test]
    fn test_apply_fallback_version() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        let repo_dir = ws_dir.join("api-gateway");
        fs::create_dir_all(&repo_dir).unwrap();
        // go.mod without a go directive
        fs::write(repo_dir.join("go.mod"), "module example.com/api-gateway\n").unwrap();

        let meta = make_metadata(&["github.com/acme/api-gateway"]);
        let integration = GoIntegration;
        integration.apply(ws_dir, &meta).unwrap();

        let content = fs::read_to_string(ws_dir.join("go.work")).unwrap();
        assert!(
            content.contains("go 1.21"),
            "should use fallback version 1.21"
        );
    }

    #[test]
    fn test_apply_overwrites_existing_go_work() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        let repo_dir = ws_dir.join("api-gateway");
        fs::create_dir_all(&repo_dir).unwrap();
        fs::write(
            repo_dir.join("go.mod"),
            "module example.com/api-gateway\n\ngo 1.22\n",
        )
        .unwrap();

        // Write stale go.work
        fs::write(ws_dir.join("go.work"), "stale content").unwrap();

        let meta = make_metadata(&["github.com/acme/api-gateway"]);
        let integration = GoIntegration;
        integration.apply(ws_dir, &meta).unwrap();

        let content = fs::read_to_string(ws_dir.join("go.work")).unwrap();
        assert!(
            content.starts_with("// Code generated by ws."),
            "go.work should be replaced, not stale"
        );
        assert!(content.contains("./api-gateway"));
    }

    #[test]
    fn test_apply_includes_context_repos() {
        let tmp = tempfile::tempdir().unwrap();
        let ws_dir = tmp.path();

        // Active repo
        let api_dir = ws_dir.join("api-gateway");
        fs::create_dir_all(&api_dir).unwrap();
        fs::write(
            api_dir.join("go.mod"),
            "module example.com/api-gateway\n\ngo 1.22\n",
        )
        .unwrap();

        // Context repo (pinned to main)
        let proto_dir = ws_dir.join("proto");
        fs::create_dir_all(&proto_dir).unwrap();
        fs::write(
            proto_dir.join("go.mod"),
            "module example.com/proto\n\ngo 1.23\n",
        )
        .unwrap();

        let meta = make_metadata_with_refs(&[
            ("github.com/acme/api-gateway", None),
            ("github.com/acme/proto", Some("main")),
        ]);
        let integration = GoIntegration;
        integration.apply(ws_dir, &meta).unwrap();

        let content = fs::read_to_string(ws_dir.join("go.work")).unwrap();
        assert!(content.contains("./api-gateway"));
        assert!(content.contains("./proto"));
        assert!(
            content.contains("go 1.23"),
            "should use highest version from all repos"
        );
    }
}
